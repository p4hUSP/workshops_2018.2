---
title: "Transformando Dados"
author: "P4H"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE,
                      message = FALSE,
                      warning = FALSE)
library(tidyverse)
library(knitr)
```

## Introdução

No nosso último encontro, trabalhamos um pouco com importação de dados e _webscraping_. Uma vez que essa etapa é realizada, como proceder com o nosso banco de dados? Como transformá-lo para algo mais significado para nós? Hoje iremos entender como funciona a estruturação e a transformação de dados, de acordo com o _tidyverse approach_.

```{r, echo = FALSE, fig.align='center', fig.height=5.0, fig.width=7.0}
knitr::include_graphics("https://raw.githubusercontent.com/p4hUSP/workshops_2018.2/master/imgs/w1_01.png")
```

## Estruturação

> tidy datasets are all alike but every messy dataset is messy in its own way (Hadley, 2014)

Estruturar um banco é uma tarefa __essencial__ antes de realizar qualquer operação. Uma banco desestruturado nos impede de transformar, visualizar e até modelar as nossas variáveis! Qual padrão iremos utilizar? Trabalharemos com bancos em que as linhas contêm observações; as colunas, variáveis e as células, valores.

```{r, echo = FALSE, fig.align='center', fig.height=5.0, fig.width=7.0}
knitr::include_graphics("https://raw.githubusercontent.com/p4hUSP/workshops_2018.2/master/imgs/tidy-1.png")
```

## Como deixar os dados tidy com o `tidyr`.

O pacote `tidyr` possui funções que irão nos auxiliar durante o processo de _estruturação_ de um banco de dados. Ela é carregada com o comando `library(tidyverse)`.

Neste workshop, iremos trabalhar com o banco de dados sobre cursos _online_ oferecidos pelo MIT e pela Harvard.

```{r}
# Carrega o pacote tidyverse
library(tidyverse)

# Lê o banco de dado
banco_1 <- read_csv('../data/w2/w2_01_use.csv') # Não se esqueça de alterar o caminho
```

Após carregar o nosso banco de dados, podemos dar uma "olhada rápida" por ele com a função `glimpse`.

```{r}
glimpse(banco_1)
```

### `gather`

Repare que as últimas quatro colunas não são exatamente variáveis. `2012`, `2013`, `2014`, `2015` e `2016` na verdade são valores de uma outra variável, ao mesmo tempo que as células correspondentes a essas variáveis dizem respeito também a outra variável. Você saberia dizer tendo em vista apenas os valores quais são essas __duas__ variáveis?

```{r}
banco_2 <- gather(banco_1, c("2012", "2013", "2014", "2015", "2016"), key = "year", value = "institutions")
```

Se você está familiarizado com a notação _wide_ e _long_, o que acabamos de fazer foi transformar um banco com características _wide_ em um _long_. É possível ir além e afirmar que o formato _tidy data_ sempre é um banco _long_.

Uma outra maneira de entender o que aconteceu é pensar que as linhas foram _derretidas_ para formar novas variáveis.

Obs: Se você tiver interesse de ir mais a fundo nas diferenças de _wide_ e _long_, assista este [vídeo](https://pt.coursera.org/lecture/designexperiments/21-long-format-and-wide-format-data-tables-dqWIT)

## Os principais verbos do dplyr.

As funções do pacote `dplyr` podem 

1. `filter`: filtra as linhas de um banco de dados de acordo com uma regra lógica.

2. `mutate`: modifica ou cria colunas de acordo com valores fornecidos.

3. `count`: conta os valores e uma variável.

    + Especialmente útil para variáveis categóricas.
    
4. `group_by` e `summarise`: são funções normalmente utilizadas em conjunto. Elas permitem realizar operações de agregações com o banco de dados e, assim, alterar a nossa unidade de análise. 

5. `rename`: altera o nome das variáveis (colunas).

### filter

Vamos voltar ao nosso banco de cursos _online_. Após realizarmos uma operação a fim de tornar o nosso banco _long_, você reparou que o número de observações aumentou? Podemos verificar isso com a função `nrow()`.

```{r}
nrow(banco_1)

nrow(banco_2)
```

De 290 observações, fomos para 1450! Em alguns casos, isso não seria um problema. Porém, neste em caso em específico, houve uma criação de vários valores NA (missing) para a coluna `institutions`. Isso ocorreu porque no fundo esse banco foi transformado previamente com objetivo de produzir um exemplo para este tutorial.

Independentemente disso, temos que arrumar esse problema e excluir as linhas com valor NA. Como realizar isso? Antes precisamos trabalhar rapidamente com avaliações lógicas no R como também entender melhor qual a natureza desse valor de _missing_ no R, o `NA`.

### Valores Booleanos e Avaliações Lógicas

Valores booleanos são resultados de operações booleanas e podem ser definidos como __verdadeiros__ ou __falsos__. Por convenção, trabalhamos com os termos em inglês. Portanto, __TRUE__ ou __FALSE__.

Por operações booleanas, podemos pensar em diferentes testes que tenham __necessariamente__ uma resposta ou verdadeira ou falsa. Por exemplo, 3 é maior do que 1? Verdadeiro! E 3 é menor do que 2? Falso! 

Vamos realizar essas duas operações no R.

```{r}
# 3 é maior do que 1?

3 > 1
```

```{r}
# 3 é maior do que 1?

3 < 2
```

Existem, obviamente, outras operações. É possível também testar a igualdade entre dois valores com `==`.

```{r}
# 2 é igual a 2?

2 == 2
```

Também podemos testar se dois valores são diferentes.

```{r}
#120 é diferente de 20?

120 != 20
```

Outras variações utilizadas são o maior ou igual (`>=`) e o menor ou igual (`<=`). Além disso, também é possível realizar essas operações com textos.

```{r}
# "harvard" é igual a "MIT"?

"Harvard" == "MIT"
```

Não iremos introduzir essa ideia aqui, mas caso seja de interesse também podemos utilizar as noções de maior e menor para textos. Você teria um palpite de como um texto pode ser maior do que outro?

Por fim, temos uma operação booleana no R para testar se um valor é _missing_. Normalmente, ao realizar a nossa coleta de dados, não conseguimos acessar os valores para algumas observações. De modo geral, representamos esses valores como _missing_. No R, representamos valores _missing_ como `NA` e para testar se um valor é NA __NÃO__ podemos utilizar o operador `==`. Por que?

```{r}
NA == NA
```

Ao invés de `==`, nós utilizamos a função `is.na()`.

```{r}
is.na(NA)
```

Para testar se um valor __não__ é um _missing_, ou seja, para testar se um valor __é válido__, precisamos adicionar um `!` antes do `is.na()`.

```{r}
!is.na("oi")

!is.na(NA)
```

| Operador       | Símbolo |
| -------------- |:-------:| 
| Igual          | ==      |
| Diferente      | !=      |
| Maior          | >       |
| Maior ou igual | >=      |
| Menor          | <       |
| Menor ou igual | <=      |
| É missing      | is.na() |

### Aplicando operações booleanas em `filter`.

Após essa breve exposição, talvez você tenha uma ideia de que como iremos _filtrar_ as observações que __não__ são _missings_ na variável `institutions`.

```{r}
banco_3 <- filter(banco_2, !is.na(institutions))
```

Pronto, agora temos um banco com 290 observações.

### mutate

Por que transformar os nossos dados? Após importar um banco para o R, antes de realizar qualquer análise, precisamos (1) garantir que as nossas variáveis estão limpas, ou seja, que todos os valores estão condizentes com o padrão esperado (2) e, às vezes, precisamos _recodificá-las_ para algo com mais significado para nós.

Quais _recodificações_ podem ser realizadas no nosso banco? Vamos utilizar novamente a função `glimpse` para ter uma ideia geral dos conteúdos das nossas variáveis.

```{r}
glimpse(banco_3)
```

Podemos, por exemplo, pensar na porcentagem de pessoas que participaram em pelo menos 50% do curso (`certified`/`participants`), que iremos chamar de (`perc_certified`).

Primeiro, podemos criar uma variável e introduzir `0`.

```{r}
banco_4 <- mutate(banco_3,
                  perc_certified = 0)
```

Em seguida, é possível calcular a proporção e inserir nessa nova variável.

Repare que no R, para dividir dois valores, utilizamos o operador `/`.

```{r}

banco_5 <- mutate(banco_4,
                  perc_certified = certified / participants)
```

Por fim, a fim de obtermos a porcentagem, multiplamos a própria variável por 100.

```{r}
banco_6 <- mutate(banco_5,
                  perc_certified = perc_certified * 100)
```

Outra estatística relevante é a porcentagem de pessoas que compareceram em pelo menos 50% do curso (`audited`/`participants`). Dessa vez, iremos criar a variável `perc_audited` em uma única operação.

```{r}
banco_7 <- mutate(banco_6, 
                  perc_audited   = (audited / participants) * 100)
```

Por fim, podemos pensar na quantidade de pessoas que ganharam certificado (`certified`) entre as que participaram em pelo menos 50% do curso (`audited`).

```{r}
banco_8 <- mutate(banco_7,
                  perc_cert_aud  = (certified / audited) * 100)
```


```{r}
glimpse(banco_8)
```

### `rename`

A função `rename` tem como objetivo alterar os __nomes__ das nossas variáveis. Digamos, por exemplo, que você queira traduzir as variáveis para o português. Uma possibilidade é alterar o nome da variável `course_title` para título curso.

```{r}
banco_9 <- rename(banco_8,
                  TITULO_CURSO = course_title)
```

```{r}
glimpse(banco_9)
```

### Verbos para Análise de Dados

Além de transformações com objetivo de __recodificar__ variáveis, o `dplyr` oferece funções para análises do nosso banco. 

#### `group by` e `summarise`

Na última seção, criamos proporções de pessoas que completaram o curso (`perc_certified`), que participaram de pelo menos 50% das aulas (`perc_audited`) e que completaram o curso entre aqueles que participaram de pelo menos 50% das aulas (`perc_cert_aud`).

Para isso, precisamos utilizar duas funções: `group_by()` e `summarise()`. Essas funções, em conjunto, são poderosíssimas para análise exploratória dos nossos dados. Vamos começar pela `summarise()`.

```{r}
summarise(banco_9, MEDIA = mean(perc_certified))
```

No último comando, descobrimos que 7,7% é a média de certificados "emitidos" por curso. O cálculo dessa média foi realizado para TODAS as observações do nosso banco. Agora, como fariámos para calcular a média de certicidados emitidos por instituição? Para isso, precisamos utilizar uma função `group_by()` __antes__.

```{r}
temp_1 <- group_by(banco_9, institutions)

summarise(temp_1, CERTIFICADOS = mean(perc_certified))
```

Percebe como `group_by()` e `summarise()` em conjunto são ferramentas poderosas? Podemos repetir o processo para as outras variáveis.

```{r}
temp_2 <- group_by(banco_9, institutions)

summarise(temp_2, PARTICIPARAM_50 = mean(perc_audited))
```

```{r}
temp_3 <- group_by(banco_9, institutions)

summarise(temp_3, CERT_PART_50 = mean(perc_cert_aud))
```

A fim de tornar o nosso trabalho mais eficiente, podemos calcular mais de uma estatística dentro de `summarise()`. Logo, ao invés de calcular cada média individualmente, podemos calcular todas de uma vez.

```{r}
temp_4 <- group_by(banco_9, institutions)

summarise(temp_4,
          CERTIFICADOS    = mean(perc_certified),
          PARTICIPARAM_50 = mean(perc_audited),
          CERT_PART_50    = mean(perc_cert_aud))
```

Além de realizar mais de um cálculo por vez, também é possível adicionar mais de uma variável para o `group_by()`. Ao fazer isso, você irá trabalhar com a combinação das duas variáveis, ou seja, caso selecionemos uma variável com __3__ categorias e uma segunda com __4__, teremos no final __12__ (3 x 4) categorias. 

Como exemplo, vamos pensar a porcentagem de certificados emitidos por ano (`perc_certified`) e por instituição (`institutions`).

```{r}
temp_5 <- group_by(banco_9,
                   year, institutions)

summarise(temp_5, CERTIFICADOS = mean(perc_certified))
```

#### `count`

Com a função `count()` podemos contar as categorias presentes dentro de uma variável.

Por exemplo, quantos cursos são oferecidos por cada instituição de ensino (`institutions`).

```{r}
count(banco_9, institutions)
```

Outro exemplo que pode ser interessante é pensar o tema dos cursos oferecidos (`course_subject`).

```{r}
count(banco_9, course_subject)
```

Também é possível, por exemplo, fornecer mais de uma variável para `count()`. Isso fará com que ela calcule a quantidade de observações presentes para as __combinações__ de categorias.

```{r}
count(banco_9, 
      institutions, course_subject)
```

## Exercício

1. Calcule a quantidade de cursos por ano e por instituição?

2. Investigue quais os temas de curso (`course_subject`) mais recorrentes para cada instituição (`institutions`).

3. Investigue a distribuição de gênero (`percent_female` e `percent_male`).

    + 2.1. Para cada instituição (`institutions`). 
    
    + 2.2. Para cada tema de curso (`course_subject`)
    
    + 2.3. Qual seria uma possível origem da diferença da proporção de mulheres entre os cursos oferecidos pela HarvardX e a MITx? (Dica: tente pensar nos cursos oferecidos por cada instituição)
    
4. Quais são os meses em que mais cursos são oferecidos?

